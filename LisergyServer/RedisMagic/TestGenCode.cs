using MessagePack;
using StackExchange.Redis;
using System.Buffers;
using System.Numerics;

namespace RedisMagic
{

    public interface IRedisKey 
    {
        public string RedisKey { get; }
    }

    public enum EntityShard
    {
        /// <summary>
        /// Individual shard means that every entity will be its own shard.
        /// Usually useful for things like players.
        /// 
        /// From a redis key like "user:123" "inventory:123" and "user:567" 
        /// their shard hints will be the whole key so every key is in its own shard
        /// 
        /// </summary>
        Component,

        /// <summary>
        /// Group means all entities that shares the same shard hit will be in the same shard.
        /// 
        /// From a redis key like "user:{123}" and "user:{567}" and  "inventory:{123}"
        /// shard hints will be generated by the actual entity ID so any operations
        /// </summary>
        Entity
    }

    public struct Entity
    {
        public EntityId Id;
        public ShardId Shard;
    }

    public struct ShardId
    {
        public string Shard;

        public string ShardKey(EntityId id) => Shard;
    }

    public struct EntityId : IRedisKey
    {
        public long Id;

        public string RedisKey => $"E{Id}";
        public override string ToString() => $"<Entity Id={Id}>";
    }

    [Serializable]
    [MessagePackObject]
    public partial class PositionComponent
    {
        [NonSerialized]
        private ushort _deltaCompression;       

        [Key(0)]
        private int _x;

        public int X
        {
            get
            {
                return _x;
            }
            set
            {
                if (value != _x) _deltaCompression |= 0;
                _x = value;
            }
        }

        [Key(1)]
        private int _y;

        public int Y
        {
            get
            {
                return _y;
            }
            set
            {
                if (value != _y) _deltaCompression |= 1;
                _y = value;
            }
        }

        public static async Task<bool> RedisRead(EntityId id, IDatabase redis, out PositionComponent comp)
        {
            var fields = await redis.HashGetAllAsync(id.RedisKey);
            comp.X = default;
            comp.Y = default;
            foreach (var f in fields)
            {
                if(f.Name == "X") comp.X = (int)f.Value;
                else if (f.Name == "Y") comp.Y = (int)f.Value;
            }
            return true;
        }

        public async Task RedisWrite(EntityId id, IDatabase redis)
        {
            var deltaFields = ArrayPool<HashEntry>.Shared.Rent(BitOperations.PopCount(_deltaCompression));
            ITransaction trans = redis.CreateTransaction();
            var i = 0;
            if ((_deltaCompression & 0) != 0)
            {
                deltaFields[i] = new HashEntry("X", _x);
                i++;
            }
            if ((_deltaCompression & 1) != 0)
            {
                deltaFields[i] = new HashEntry("Y", _y);
                i++;
            }
            await trans.HashSetAsync(id.RedisKey, deltaFields);
            if (!await trans.ExecuteAsync())
            {
                throw new Exception("Fail write");
            }
        }

    }
}
